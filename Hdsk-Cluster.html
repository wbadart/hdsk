<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Hdsk.Cluster</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Hdsk.Cluster.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">hdsk-0.1.0.0: Unified data science toolkit for Haskell and more</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Will Badart 2018</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Hdsk.Cluster</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides an implementation of the k-means clustering
algorithm. K-means is well suited to problems where the number of
clusters is known and fixed (it is a parameter to the algorithm).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:kmeans">kmeans</a> :: <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [[<a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>]] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:kmedoids">kmedoids</a> :: <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [[<a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>]] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:kclusterer">kclusterer</a> :: <a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup =&gt; <a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (tup -&gt; tup -&gt; <a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>) -&gt; ([tup] -&gt; tup) -&gt; <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:cluster">cluster</a> :: (<a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup, <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; [tup] -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:improve">improve</a> :: (<a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup, <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; ([tup] -&gt; tup) -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [[<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]]</li><li class="src short"><a href="#v:meanSqDist">meanSqDist</a> :: (<a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d, <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; ([tup] -&gt; tup) -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; d</li><li class="src short"><a href="#v:midpoints">midpoints</a> :: ([tup] -&gt; tup) -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [tup] -&gt; [tup]</li><li class="src short"><a href="#v:centroid">centroid</a> :: <a href="../base-4.11.1.0/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a =&gt; [[a]] -&gt; [a]</li><li class="src short"><a href="#v:medoid">medoid</a> :: (<a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d, <a href="../base-4.11.1.0/Prelude.html#t:Fractional" title="Prelude">Fractional</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; [tup] -&gt; tup</li><li class="src short"><a href="#v:closestTo">closestTo</a> :: <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d =&gt; (tup -&gt; tup -&gt; d) -&gt; tup -&gt; [tup] -&gt; tup</li><li class="src short"><a href="#v:minkowski">minkowski</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; a -&gt; [a] -&gt; [a] -&gt; a</li><li class="src short"><a href="#v:distManhattan">distManhattan</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; [a] -&gt; [a] -&gt; a</li><li class="src short"><a href="#v:distEuclidean">distEuclidean</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; [a] -&gt; [a] -&gt; a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:kmeans" class="def">kmeans</a> :: <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [[<a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>]] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Hdsk.Cluster.html#kmeans" class="link">Source</a> <a href="#v:kmeans" class="selflink">#</a></p><div class="doc"><p><em>O(inkD)</em> Run the kmeans clustering algorithm over the given
 dataset. Returns a list of cluster labels which corresponds 1-1 with
 the input list of data points.</p></div></div><div class="top"><p class="src"><a id="v:kmedoids" class="def">kmedoids</a> :: <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [[<a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>]] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Hdsk.Cluster.html#kmedoids" class="link">Source</a> <a href="#v:kmedoids" class="selflink">#</a></p><div class="doc"><p><em>O(ikD*n^2)</em> Run the kmedoids clustering algorithm over the given
 dataset.</p></div></div><div class="top"><p class="src"><a id="v:kclusterer" class="def">kclusterer</a> <a href="src/Hdsk.Cluster.html#kclusterer" class="link">Source</a> <a href="#v:kclusterer" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>Minimum improvement <em>eta</em></p></td></tr><tr><td class="src">-&gt; (tup -&gt; tup -&gt; <a href="../base-4.11.1.0/Prelude.html#t:Double" title="Prelude">Double</a>)</td><td class="doc"><p>Distance metric between points</p></td></tr><tr><td class="src">-&gt; ([tup] -&gt; tup)</td><td class="doc"><p>Measure of center of cluster</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>The parameter <em>k</em></p></td></tr><tr><td class="src">-&gt; [tup]</td><td class="doc"><p>The list of data points</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</td><td class="doc"><p>Final clustering</p></td></tr></table></div><div class="doc"><p>Convenience function for creating clustering function. For
 instance, <code><a href="Hdsk-Cluster.html#v:kmeans" title="Hdsk.Cluster">kmeans</a></code>, as defined in this module, is a <code><a href="Hdsk-Cluster.html#v:kclusterer" title="Hdsk.Cluster">kclusterer</a></code> with
 <code><a href="Hdsk-Cluster.html#v:distEuclidean" title="Hdsk.Cluster">distEuclidean</a></code> distance metric, <code><a href="Hdsk-Cluster.html#v:centroid" title="Hdsk.Cluster">centroid</a></code> center measure, and
 <em>eta = 0.01</em>.</p></div></div><div class="top"><p class="src"><a id="v:cluster" class="def">cluster</a> :: (<a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup, <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; [tup] -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Hdsk.Cluster.html#cluster" class="link">Source</a> <a href="#v:cluster" class="selflink">#</a></p><div class="doc"><p><em>O(nkD)</em> where <em>n</em> is the number of data points, <em>k</em> is the number
 of clusters, and <em>D</em> is the dimensionality of the data. Run one
 iteration of the k-means algorithm. The parameter <em>k</em>, number of
 clusters, is implied by the length of the list of initial centroids.
 Returns a list of cluster labels (encoded as integers) which
 correspond 1-1 with the given list of data points.</p></div></div><div class="top"><p class="src"><a id="v:improve" class="def">improve</a> :: (<a href="../base-4.11.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> tup, <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; ([tup] -&gt; tup) -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [[<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]] <a href="src/Hdsk.Cluster.html#improve" class="link">Source</a> <a href="#v:improve" class="selflink">#</a></p><div class="doc"><p><em>O(inkD)</em> where <em>n</em> is the number of data points, <em>k</em> is the number
 of clusters, <em>D</em> is the dimensionality of the data, and <em>i</em> is the
 number of iterations. Improve the quality of the clustering.
 Generates an infinite list of clusterings.</p></div></div><div class="top"><p class="src"><a id="v:meanSqDist" class="def">meanSqDist</a> :: (<a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d, <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; ([tup] -&gt; tup) -&gt; [tup] -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; d <a href="src/Hdsk.Cluster.html#meanSqDist" class="link">Source</a> <a href="#v:meanSqDist" class="selflink">#</a></p><div class="doc"><p><em>O(nD)</em> Calculate the mean squared distance from each point in a
 cluster to the centroid.</p></div></div><div class="top"><p class="src"><a id="v:midpoints" class="def">midpoints</a> :: ([tup] -&gt; tup) -&gt; [<a href="../base-4.11.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [tup] -&gt; [tup] <a href="src/Hdsk.Cluster.html#midpoints" class="link">Source</a> <a href="#v:midpoints" class="selflink">#</a></p><div class="doc"><p><em>O(nD)</em> where <em>n</em> is the number of data points and <em>D</em> is the
 dimensionality of the data. Calculate the midpoints of clusters
 according to a metric (<code><a href="Hdsk-Cluster.html#v:centroid" title="Hdsk.Cluster">centroid</a></code>, for instance).</p></div></div><div class="top"><p class="src"><a id="v:centroid" class="def">centroid</a> :: <a href="../base-4.11.1.0/Prelude.html#t:Fractional" title="Prelude">Fractional</a> a =&gt; [[a]] -&gt; [a] <a href="src/Hdsk.Cluster.html#centroid" class="link">Source</a> <a href="#v:centroid" class="selflink">#</a></p><div class="doc"><p><em>O(nD)</em> where <em>n</em> is the number of points and <em>D</em> is the
 dimensionality of each point. Compute the mean of a list of
 D-dimensional points.</p></div></div><div class="top"><p class="src"><a id="v:medoid" class="def">medoid</a> :: (<a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d, <a href="../base-4.11.1.0/Prelude.html#t:Fractional" title="Prelude">Fractional</a> d) =&gt; (tup -&gt; tup -&gt; d) -&gt; [tup] -&gt; tup <a href="src/Hdsk.Cluster.html#medoid" class="link">Source</a> <a href="#v:medoid" class="selflink">#</a></p><div class="doc"><p><em>O(n^2)</em> Compute the medoid of a list of points.</p></div></div><div class="top"><p class="src"><a id="v:closestTo" class="def">closestTo</a> :: <a href="../base-4.11.1.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> d =&gt; (tup -&gt; tup -&gt; d) -&gt; tup -&gt; [tup] -&gt; tup <a href="src/Hdsk.Cluster.html#closestTo" class="link">Source</a> <a href="#v:closestTo" class="selflink">#</a></p><div class="doc"><p><em>O(kD)</em> where <em>k</em> is the number of points to consider and <em>D</em> is
 the dimensionality of the data. Select from a list of points that
 which is closest to a given point <em>x</em> according to a given distance
 metric. For instance, in one dimension:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>closestTo (\x y -&gt; abs $ sum (zipWith (-) x y)) [0] [[1], [2]]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1.0]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:minkowski" class="def">minkowski</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; a -&gt; [a] -&gt; [a] -&gt; a <a href="src/Hdsk.Cluster.html#minkowski" class="link">Source</a> <a href="#v:minkowski" class="selflink">#</a></p><div class="doc"><p><em>O(D)</em> where <em>D</em> is the dimensionality of the vectors. General
 distance metric between two vectors/ data points in the same vector
 space. The first parameter <code>p</code> corresponds to the <em>L^p</em> space to
 compute the norm (e.g. <code>p = 2</code> is Euclidean distance).</p></div></div><div class="top"><p class="src"><a id="v:distManhattan" class="def">distManhattan</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; [a] -&gt; [a] -&gt; a <a href="src/Hdsk.Cluster.html#distManhattan" class="link">Source</a> <a href="#v:distManhattan" class="selflink">#</a></p><div class="doc"><p>Common case of <code><a href="Hdsk-Cluster.html#v:minkowski" title="Hdsk.Cluster">minkowski</a></code> is with <em>p = 1</em> for Manhattan distance.</p></div></div><div class="top"><p class="src"><a id="v:distEuclidean" class="def">distEuclidean</a> :: <a href="../base-4.11.1.0/Numeric.html#t:Floating" title="Numeric">Floating</a> a =&gt; [a] -&gt; [a] -&gt; a <a href="src/Hdsk.Cluster.html#distEuclidean" class="link">Source</a> <a href="#v:distEuclidean" class="selflink">#</a></p><div class="doc"><p>Common case of <code><a href="Hdsk-Cluster.html#v:minkowski" title="Hdsk.Cluster">minkowski</a></code> is with <em>p = 2</em> for Euclidean distance.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>